<!DOCTYPE html>
<html lang="en">
<head>
  <title>Order of Saints</title>
  <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="css/style.css"/>
    <script src="/socket.io/socket.io.js"></script>
    <script src="https://npmcdn.com/babel-core@5.8.38/browser.min.js"></script>
    <script type="text/babel" >
        "use strict";
      
      const user = `user${(Math.floor((Math.random() * 1000)) + 1)}`;
      var room;
      let socket;
      let draws = {};
      let enemiesToDraw = {};
      var canvas = document.getElementById('myCanvas');
      var ctx = canvas.getContext('2d');
      
      //object to keep track of pressed keys
      var keysDown = {};
       
      //draw all objects
      const draw = () => {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        ctx.font = "50px Arial";
        ctx.fillText(room, 10, 50);
        
        let keys = Object.keys(draws);
        
        //draw players
        for(let i = 0; i < keys.length; i++)
        {
          const drawCall = draws[keys[i]];
          
          ctx.beginPath();
          ctx.arc(drawCall.x, drawCall.y, drawCall.rad, 0, 2 * Math.PI);
          ctx.fillStyle = drawCall.fill;
          ctx.fill();
          ctx.strokeStyle = drawCall.stroke;
          ctx.lineWidth = 5;
          ctx.stroke();
          
          //draw attack if attacking
          if(drawCall.attacking)
          {
            var dx = drawCall.mouse.x - drawCall.x;
            var dy = drawCall.mouse.y - drawCall.y;
            
            var mag = Math.sqrt(dx * dx + dy * dy);
            dx = dx/mag;
            dy = dy/mag;
            
            var attackX = dx * drawCall.range;
            var attackY = dy * drawCall.range;
            
            ctx.beginPath();
            ctx.moveTo(drawCall.x, drawCall.y);
            ctx.lineTo(drawCall.x + attackX, drawCall.y + attackY);
            ctx.stroke();
            
            checkCollisions(drawCall.x + attackX, drawCall.y + attackY);
            
            drawCall.attacking = false;
          }
        }
        
        keys = Object.keys(enemiesToDraw);
        
        for(var i = 0; i < keys.length; i++)
        {
          const enemy = enemiesToDraw[keys[i]];
          ctx.beginPath();
          ctx.arc(enemy.x, enemy.y, enemy.rad, 0, 2 * Math.PI);
          ctx.fillStyle = enemy.fill;
          ctx.fill();
        }
        
      }
      
      //initialize player properties
      const setupPlayer = () => {
        const time = new Date().getTime();
        let x = canvas.width/2;
        let y = canvas.height/2;
        let score = 0;
        let attacking = false;
        let attackRange = 70;
        let mouse = {};
        let fill = '#' + ("000000" + Math.random().toString(16).slice(2, 8).toUpperCase()).slice(-6); //code from http://www.daverabideau.com/blog/
        let stroke = '#' + ("000000" + Math.random().toString(16).slice(2, 8).toUpperCase()).slice(-6);
        draws[user] = {lastUpdate: time, x: x, y: y, score: score, attacking: attacking, range: attackRange, mouse: mouse, rad: 25, fill: fill, stroke: stroke};
      }
      
      //receive enemy properties
      const setupEnemies = (enemies) => {
        enemiesToDraw = enemies;
        draw();
      }
      
      const checkCollisions = (weaponX, weaponY) => {
        socket.emit('collisionCheck', {weaponX: weaponX, weaponY: weaponY});
      }
      
      
      //add parameters from server to draw stack
      const handleDraw = (data) => {
        if(!draws[data.name])
        {
          draws[data.name] = data.coords;
        }
        else if(data.coords.lastUpdate > draws[data.name].lastUpdate)
        {
          draws[data.name] = data.coords;
        }
        draw();
      }
      
      /*const handleLeave = (data) =>{
        delete draws[data.user];
      }*/
      
      //send key presses every interval
      const sendKeys = () => {
        socket.emit('movement', {name: user, room: room, keysDown:keysDown, coords: draws[user], winWidth: window.innerWidth, winHeight: window.innerHeight});
      }
      
      //request enemy update every interval
      const moveEnemies = () => {
        socket.emit('updateEnemies', { room: room, name: user });
      }
      
      const redrawCanvas = () => {
        ctx.strokeRect(0,0, window.innerWidth, window.innerHeight);
      }
      
      const resizeCanvas = () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        redrawCanvas();
      }
      
      //receive room name
      const displayRoom = (roomName) => {
        console.log("display room");
        room = roomName;
        draw();
      }
    
      const init = () => {
      
        window.addEventListener('resize', resizeCanvas, false); //resize canvas to window size
        resizeCanvas(); //first canvas draw
        setupPlayer(); //inintialize player 
        
        socket = io.connect();
        
        // join a room, draw, and send updates when connected
        socket.on('connect', () => {
          //add a circle to the data structure upon connecting
          socket.emit('join', {name: user, playerX: draws[user].x, playerY: draws[user].y, spawnWidth: window.innerWidth, spawnHeight: window.innerHeight});
          draw();
          setInterval(sendKeys, 50);
          setInterval(moveEnemies,47);
        });
        
        //keep track of keysDown that are down
        document.onkeydown = (e) => {
          keysDown[e.keyCode] = true;
        };
        document.onkeyup = (e) => {
          keysDown[e.keyCode] = false;
        };
        
        //check for mouse activity
        document.onmousedown = (e) => {
          if(e.button === 0)
          {
            draws[user].mouse.x = e.pageX - e.target.offsetLeft;
            draws[user].mouse.y = e.pageY - e.target.offsetTop;
            draws[user].attacking = true;
            socket.emit('updateAttack', { name: user, room: room, coords: draws[user] });
          }
        };
        
        //server emissions
        socket.on('learnRoom', displayRoom);
        socket.on('spawnEnemies', setupEnemies);
        socket.on('enemiesUpdated', setupEnemies);
        socket.on('move', handleDraw);
        socket.on('attack', handleDraw);
        //socket.on('userLeft', handleLeave);
      };
    
    window.onload = init;
    
    </script>
</head>
<body>
  <canvas id="myCanvas"></canvas>
</body>
</html>